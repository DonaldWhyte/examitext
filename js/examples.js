/* This file just contains all the example texts that are available to use. */

EXAMPLES =
[

	// Text Document
	[
		// English
		"The Arc is located on the right bank of the Seine at the centre of a dodecagonal configuration of twelve radiating avenues. It was commissioned in 1806 after the victory at Austerlitz by Emperor Napoleon at the peak of his fortunes. Laying the foundations alone took two years and, in 1810, when Napoleon entered Paris from the west with his bride Archduchess Marie-Louise of Austria, he had a wooden mock-up of the completed arch constructed. The architect, Jean Chalgrin, died in 1811 and the work was taken over by Jean-Nicolas Huyot. During the Bourbon Restoration, construction was halted and it would not be completed until the reign of King Louis-Philippe, between 1833 and 1836, by the architects Goust, then Huyot, under the direction of Héricart de Thury. On 15 December 1840, brought back to France from Saint Helena, Napoleon's remains passed under it on their way to the Emperor's final resting place at the Invalides. Prior to burial in the Panthéon, the body of Victor Hugo was exposed under the Arc during the night of 22 May 1885.\n\nThe sword carried by the Republic in the Marseillaise relief broke off on the day, it is said, that the Battle of Verdun began in 1916. The relief was immediately hidden by tarpaulins to conceal the accident and avoid any undesired ominous interpretations[citation needed]. On 7 August 1919, Charles Godefroy successfully flew his biplane under the Arc. Jean Navarre was the pilot who was tasked to make the flight, but he died on 10 July 1919 when he crashed near Villacoublay while training for the flight.\n\nFollowing its construction, the Arc de Triomphe became the rallying point of French troops parading after successful military campaigns and for the annual Bastille Day Military Parade. Famous victory marches around or under the Arc have included the Germans in 1871, the French in 1919, the Germans in 1940, and the French and Allies in 1944[10] and 1945. A United States postage stamp of 1945 shows the Arc de Triomphe in the background as victorious American troops march down the Champs-Élysées and U.S. airplanes fly overhead on 29 August 1944. After the interment of the Unknown Soldier, however, all military parades (including the aforementioned post-1919) have avoided marching through the actual arch. The route taken is up to the arch and then around its side, out of respect for the tomb and its symbolism. Both Hitler in 1940 and de Gaulle in 1944 observed this custom.",

		// French
		"Né le 11 mars 1727 ou 1728, fils de Paul Blanchet, alors marchand de café, et de Marie Ann Fournier, le jeune André fut baptisé dans la chapelle de Ryder Court, à Soho. Le 30 juin 1740, il était embauché comme apprenti par Edward Mountenay, bijoutier-orfèvre établi sur Foster Lane, non loin de la Compagnie des orfèvres de Londres. Il anglicisa à cette occasion son nom d'André Blanchet en Andrew Planche. Le 22 septembre 1747, à l'issue de ses sept années d'apprentissage, il épousait Sarah Jones à l'église St Pancras.\n\nLa réalisation de modèles et la fabrication de porcelaine ont pu lui être enseignées par son père, qui avait vécu à Meissen, en Saxe. Dès ses 17 ans, à Derby, le jeune Planché aurait créé de petits objets de porcelaine et en 1749 il travaillait pour William Littler, à Longton Hall. Il est aussi possible qu'il y ait un lien entre Marie Ann Fournier, la mère de Planché, et Louis Fournier, faiseur de modèles qui travailla à Vincennes puis à Chantilly ; Planché lui-même s'identifie peut-être au Flanchet connu pour avoir exercé la même activité à Chelsea après avoir été en France l'élève de Jean-Claude Duplessis.\n\nSa présence à Derby est attestée en tout cas à partir de 1751, année du baptême à St Alkmund de deux de ses enfants, Paul Edmund et James. Ce dernier ne vécut que jusqu'en décembre 1754. En 1756, deux autres fils sont enregistrés, James, « fils bâtard d’Andrew Planche et Margaret Burroughd », et William, « fils d’Andrew Planche et de sa femme Sarah. Un accord, daté du 1er janvier de cette même année et qui nous est parvenu, témoigne de son implication avec William Duesbury dans la nouvelle manufacture de porcelaine établie sur Nottingham Road, qui devint plus tard la société Royal Crown Derby.",

		// German
		"Die Geschichte der Bank of New Zealand reicht weit zurück bis in die Gründerzeit der einstmals britischen Kolonie Neuseeland. Mitte des 19. Jahrhunderts gab es in der Kolonie eine notorische Knappheit an umlaufendem Geld, dem Neuseeland Pfund. Mehrere Versuche der neuseeländischen Gouverneure Robert FitzRoy, George Edward Grey und Thomas Gore Browne, diese Situation zu ändern, schlugen fehl. Alle vier zwischen 1840 und 1857 in der Kolonie neu gegründeten Banken verfehlten ihre Ziele und wurden wieder aufgelöst. Die einzige Bank, die den Geldmarkt der Kolonie versorgte und gleichzeitig kontrollierte, war die australische Union Bank of Australia, aus der später über eine Fusion mit der Bank of Australasia die Australia and New Zealand Bank (ANZ) hervorging.\n\nDie Geldknappheit, die alles dominierende Union Bank of Australia und der Beginn des Otago-Goldrauschs im Mai 1861 waren die Gründe, das neuseeländische Bankensystem auf eine neue und gesündere Grundlage zu stellen. Der New Zealand Bank Act 1861 erteilte die Erlaubnis, die Bank of New Zealand zu gründen, eigene Banknoten zu drucken und in Umlauf zu bringen. Das gleiche Recht erhielt u.a. auch die Bank of New South Wales über den Bank of New South Wales Act 1861. Drei weitere Banken sollten 1864, 1873 und 1874 mit entsprechenden Rechten folgen.\n\n\n\n\n\nBankgebäude in ländlicher Gegend, Middlemarch\n\nNach der Gründung der Bank of New Zealand am 29. Juli 1861 folgte der Start ihrer ersten Geschäftstätigkeit am 16 Oktober 1861 in Auckland. Es folgte die Eröffnung der ersten Zweigstelle am 2. Dezember 1881 in Dunedin auf der Südinsel, der Stadt, die durch den Goldrausch in der Provinz Otago über einige Jahrzehnte zur größten und reichsten Stadt Neuseelands werden sollte.",

		// Italian
		"Vive nelle acque fredde dell'Oceano Antartico, a grandi profondità, fino a 2200 m. I giovani si possono incontrare fino a 1000 m.\n\nIn assenza di un numero sufficiente di campioni provenienti da zone diverse (eccetto che per le paralarvae, lo stadio giovane del calamaro, che vivono nella zona antartica), la ripartizione geografica del calamaro deve essere dedotta da fonti indirette. Informazioni circa la distribuzione e gli spostamenti si possono trovare dai resti recuperati dallo stomaco dei suoi predatori, anche se alcuni di essi, come il capodoglio, compiono grandi viaggi negli oceani, mentre gli albatros, un altro predatore del calamaro colossale, possono allontanarsi fino a 1200 km dai nidi[1].\n\nDa alcuni esemplari catturati e dai resti rinvenuti all'interno dei capodogli si può dedurre che il calamaro colossale vive fino a 2200 metri di profondità (nella cosiddetta zona batipelagica), mentre i giovani non possono andare oltre i 1000 metri di profondità (zona mesopelagica).",

		// Spanish
		"La polilla crepuscular de Madagascar, o simplemente polilla crepuscular (Chrysiridia rhipheus), es una gran polilla de vuelo diurno de la familia Uraniidae, con una envergadura de siete a nueve centímetros. Se la considera uno de los miembros más bellos e impresionantes del orden Lepidoptera. Famosa en todo el mundo, figura en muchos libros de mesa auxiliar que tratan este orden, y es muy buscada por los coleccionistas Es muy colorida, pero muchos de estos colores no se forman por pigmentos, sino por fenómenos físicos como polarización, iridiscencia o refracción de la luz en las escamas de las alas. Por ello, es una especie objeto de numerosos estudios ópticos.\n\nEl entomólogo británico Dru Drury la consideró una mariposa, y la describió en 1773 dentro del género Papilio. En 1823, Jakob Hübner la reclasificó en el género de polillas Chrysiridia. Más adelante, otras descripciones dieron lugar a sinónimos varios como Chrysiridia madagascarensis (Lesson, 1831).\n\nAl principio, se creía que era originaria de China o Bengala, pero luego se descubrió que era endémica de Madagascar. Se encuentra en distintas regiones de la isla en diferentes momentos del año, con máximos poblacionales entre marzo y agosto y mínimos entre octubre y diciembre. Cada año, miles de individuos migran del este al oeste de la isla.",

		// Portuguese
		"A coroa solar expande-se continuamente no espaço, criando o vento solar, uma corrente de partículas carregadas que estende-se até a heliopausa, a cerca de 100 UA do Sol. A bolha no meio interestelar formada pelo vento solar, a heliosfera, é a maior estrutura contínua do Sistema Solar.\n\nO Sol orbita em torno do centro da Via Láctea, atravessando no momento a Nuvem Interestelar Local de gás de alta temperatura, no interior do Braço de Órion da Via Láctea, entre os braços maiores Perseus e Sagitário. Das 50 estrelas mais próximas do Sistema Solar, num raio de até 17 anos-luz da Terra, o Sol é a quarta maior em massa. Diferentes valores de magnitude absoluta foram dados para o Sol, como, por exemplo, 4,85, e 4,81. O Sol orbita o centro da Via Láctea a uma distância de cerca de 24 a 26 mil anos-luz do centro galáctico, movendo-se geralmente na direção de Cygnus e completando uma órbita entre 225 a 250 milhões de anos (um ano galáctico). A estimativa mais recente e precisa da velocidade orbital do sol é da ordem de 251 km/s.\n\nVisto que a Via Láctea move-se na direção da constelação Hidra, com uma velocidade de 550 km/s, a velocidade do Sol relativa à radiação cósmica de fundo é de 370 km/s, na direção da constelação Crater.",

		// Swedish
		"Zapatarallen beskrevs formellt 1927 av den amerikanska herpetologen Thomas Barbour tillsammans med ornitologen James Lee Peters. De ansåg arten vara så pass distinkt att de placerade den i det egna släktet Cyanolimnas. Släktnamnet härstammar ifrån gammalgrekiskans kuanos \"mörkblå\" och nylatinets limnas som betyder \"rall\". Artepitetet cerverai hedrar rallens upptäckare, Fermín Zanón Cervera, en spansk soldat som stannat kvar efter spansk-amerikanska kriget och som blev professionell naturalist.\n\nBarbour hade slagit följe med Cervera under sina resor på Kuba och när han fick höra talas om alla de ovanliga fåglar som skulle finnas i Zapataområdet, så skickade han ut Cervera på ett flertal expeditioner i regionen. Cervera fann slutligen rallen i närheten av den lilla byn Santo Tomás. Cervera var också den som upptäckte zapatagärdsmygen och zapatasparven.\n\nFamiljen rallar omfattar mer än 150 arter uppdelade på minst 50 släkten, där det exakta antalet varierar beroende på auktoritet. Zapatarallen placeras i det egna släktet Cyanolimnas, som taxonomiskt brukar placeras mellan Neocrex och Pardirallus, vilket är två andra släkten av rallar i nya världen. Alla sex arter inom dessa tre släkten har lång näbb, fem har ganska färglösa fjäderdräkter och alla utom en har röd näbbas.\n\nEtt fossil, av vad som tros vara samma art, har återfunnits på Isla de la Juventud men det är mindre än den idag förekommande arten men på grund av bristen på tillgängligt material är det omöjligt att fastställa om det rör sig om ett annat taxon.",

		// Finnish
		"Moottoripyöräily on ajamista moottoripyörällä ja suosittu vapaa-ajan harrastus. Moottoripyöräilyn harrastajia kutsutaan Suomessa motoristeiksi, mutta englannissa samaa kantaa oleva sana tarkoittaa kuitenkin autoilijoita.\n\nMoottoripyörällä on suosittua ajaa maaseudun mutkateitä rauhallisella nopeudella maisemista ja vapauden tunteesta nauttien. Osa harrastajista pitää suorituskykyisillä ajoneuvoilla ajamisesta. Moottoripyörä on tähän sopiva väline, koska sen hinta on alhainen suhteessa suorituskykyyn. Moottoripyörän ajotaitoa voi kohentaa ja ylläpitää rata-ajolla, jota voidaan harrastaa ratapäivillä. Moottoripyörällä voi tehdä myös matka-ajoa.\n\nAiemmin moottoripyöräilyyn liittyi paljon negatiivisia mielleyhtymiä valtaväestön keskuudessa. Motoristit nähtiin kapinallisina tai häirikköinä, ja heidän ajotapaansa ja pukeutumistaan arvosteltiin. Nykyään moottoripyörä on jokaisen ulottuvilla ja harrastuksesta on tullut hyväksytty kaikissa kansankerroksissa. Edelleen jotkin perinteiset moottoripyörämerkit saatetaan rinnastaa järjestäytyneeseen rikollisuuteen."
	],

	// Chat Log
	[
		// English
		"[User]: So what's the deal with Examitext anyway? What does it do?\n[Donald]: Well, it analyses text documents, chat logs and source code and provides statistics on them.\n[User]: Statistics? Hmm...what kind of statistics?\n[Donald]: Stuff like average message length for a participant in a chat, average paragraph length for text documents, list of most used functiond for source code, the lsit goes on!\n[Donald]: Also, for source code, it can provide an inheritence hierarchy for your classes if you're using a language that directly supports Object Oriented Programming!\n[User]: Sounds good, I guess I'll have to give it a try.\n[Another User]: Me too, I have to what Examitext is all about!",

		// French
		"[Utilisateur]: Alors, quel est le deal avec Examitext de toute façon? Que faut-il faire?\n[Donald]: Eh bien, il analyse les documents texte, les historiques de conversation et le code source et fournit des statistiques sur eux.\n[Utilisateur]: Statistique? Hmm ... quel genre de statistiques?\n[Donald]: Des trucs comme la longueur moyenne des messages d'un participant à un chat, la durée moyenne de l'alinéa pour les documents texte, liste de functiond le plus utilisé pour le code source, la LSIT continue!\n[Donald]: Aussi, pour le code source, il peut fournir une hiérarchie héritage pour vos classes, si vous utilisez un langage qui supporte directement Programmation Orientée Objet!\n[Utilisateur]: Ça sonne bien, je suppose que je vais devoir lui donner un essai.\n[Un autre utilisateur]: Moi aussi, j'ai à ce Examitext est tout!",

		// German
		"[User]: Also, was ist der Deal mit Examitext überhaupt? Was tut sie?\n[Donald]: Nun, analysiert es Textdokumente, Chat-Protokolle und Quellcode und liefert statistische Daten über sie.\n[User]: Statistiken? Hmm ... was für eine Statistik?\n[Donald]: Stuff wie durchschnittliche Länge der Nachricht für einen Teilnehmer in einem Chat, durchschnittliche Absatz Länge für Textdokumente, die Liste der am häufigsten verwendeten functiond für Quellcode, geht die lsit auf!\n[Donald]: Auch für Quellcode, es kann ein inheritence Hierarchie für Ihre Klassen bieten, wenn Sie eine Sprache, die direkt unterstützt Object Oriented Programming bist!\n[User]: Hört sich gut an, ich denke, ich muss es versuchen.\n[Ein anderer User]: Ich auch, ich habe zu dem, was Examitext alles um!",

		// Italian
		"[Utente]: Allora, qual è l'accordo con Examitext comunque? Che cosa fa?\n[Donald]: Beh, analizza i documenti di testo, la chat e il codice sorgente e fornisce informazioni su di loro.\n[Utente]: statistiche? Hmm ... che tipo di statistiche?\n[Donald]: Stuff come la lunghezza media dei messaggi per un partecipante in una chat, comma lunghezza media per documenti di testo, la lista dei functiond più utilizzati per il codice sorgente, il lsit continua!\n[Donald]: Inoltre, per il codice sorgente, può fornire una gerarchia di ereditarietà per le classi se si sta utilizzando un linguaggio che supporta direttamente Object Oriented Programming!\n[Utente]: Suona bene, credo che dovrò fare un tentativo.\n[Un altro utente]: Anche a me, devo cosa Examitext è tutto!",

		// Spanish
		"[Usuario]: Entonces, ¿qué pasa con Examitext de todos modos? ¿Qué hacer?\n[Donald]: Bueno, se analizan documentos de texto, registros de chat y el código fuente y proporciona estadísticas sobre ellos.\n[Usuario]: estadísticas? Hmm ... ¿qué tipo de estadísticas?\n[Donald]: cosas como la longitud promedio de los mensajes de un participante en un chat, longitud de los párrafos media para documentos de texto, lista de functiond más utilizado para el código fuente, el lsit continúa!\n[Donald]: Además, para el código fuente, puede proporcionar una jerarquía de sucesiones para las clases si estás usando un lenguaje que apoya directamente la programación orientada a objetos!\n[Usuario]: Me parece bien, supongo que tendré que darle una oportunidad.\n[Otro usuario]: Yo también, tengo que Examitext lo es todo!",

		// Portuguese
		"[User]: Então, qual é o negócio com Examitext de qualquer maneira? O que ele faz?\n[Donald]: Bem, ele analisa documentos de texto, logs de bate-papo e código-fonte e fornece estatísticas sobre eles.\n[User]: Estatísticas? Hmm ... que tipo de estatísticas?\n[Donald]: Coisas como o comprimento médio das mensagens de um participante em um bate-papo, o comprimento médio parágrafo para documentos de texto, lista de functiond mais utilizado para o código-fonte, o lsit continua!\n[Donald]: Além disso, para o código-fonte, pode fornecer uma hierarquia de herança para suas aulas, se você estiver usando uma linguagem que suporta diretamente Programação Orientada a Objetos!\n[User]: Parece bom, acho que vou ter que dar-lhe uma tentativa.\n[User Outro]: Eu também, eu tenho o que Examitext tem tudo a ver!",

		// Swedish
		"[Användare]: Så vad är det med Examitext ändå? Vad gör det?\n[Kalle]: Tja, analyserar den textdokument, loggar chatt och källkod och tillhandahåller statistik över dem.\n[Användare]: Statistik? Hmm ... vilken typ av statistik?\n[Kalle]: sånt genomsnitt meddelandets längd för en deltagare i en chatt, genomsnittlig punkt längd för textdokument, listan över mest använda functiond för källkod, går lsit på!\n[Kalle]: Även för källkoden, kan det ge en inheritence hierarki för dina klasser om du använder ett språk som direkt stöder objektorienterad programmering!\n[Användare]: Låter bra, jag antar att jag måste ge det ett försök.\n[Annans]: Jag också, jag har vad Examitext handlar om!",

		// Finnish
		"[Käyttäjä]: Joten mitä käsitellä Examitext anyway? Mitä se tekee?\n[Donald]: No, se analysoi tekstidokumentteja, chat lokit ja lähdekoodia ja tarjoaa tilastoja niistä.\n[Käyttäjä]: tilastot? Hmm ... millaisia ​​tilastoja?\n[Donald]: kamaa kuin keskimääräinen viestin pituus osallistujan chat, keskimääräinen kappaleen pituus tekstidokumentteja, luettelo eniten käytetty functiond varten lähdekoodia, lsit jatkuu!\n[Donald]: Edelleen, lähdekoodia, se voi tarjota inheritence hierarkian oppitunneille Jos käytät kieltä suoraan tukee Olio-ohjelmointi!\n[Käyttäjä]: Kuulostaa hyvältä, Taidan joutua kokeilemaan sitä.\n[Toisen käyttäjän]: Niin minäkin, olen mitä Examitext on kyse!",
	],

	// Source File
	[
		// HTML
		"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<!DOCTYPE html\n\t\t  PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\t\t  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> \n\n\t\t<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n\n\t\t<head>\n\t\t\t<title>Example Document for Examitest</title>\n\n\t\t\t<!-- External libraries -->\n\t\t\t<script type=\"text/javascript\" src=\"../js/jquery-1.6.2.js\"></script>\n\n\t\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"../css/reset.css\" />\n\t\t\t<link rel=\"stylesheet\" type=\"text/css\" href=\"../css/style.css\" />\n\n\t\t</head>\n\n\t\t<body>\n\n\t\t\t<div id=\"container\">\n\t\t\t\t<div id=\"header\">\n\t\t\t\t\tExample Document for Examitext\n\t\t\t\t</div>\n\n\t\t\t\t<div id=\"navigation\">\n\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>\n\t\t\t\t\t</ul>\n\t\t\t\t</div>\n\n\t\t\t\t<div id=\"content\">\n\t\t\t\t\t<a href=\"#\">This</a> is a hyperlink.\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"push\"></div>\n\t\t\t</div>\n\n\t\t\t<div id=\"footer\">\n\t\t\t\t<p>Copyright No-One In Particular 2052</p>\n\t\t\t</div>\n\n\t\t</body>\n\n\t\t</html>",

		// JavaScript
		"function writeText(text) {\n\tdocument.write(text + \"<br />\");\n}\n\nfunction getTextFromUser() {\n\tvar text = \"\";\n\tdo {\n\t\ttext = prompt(\"Enter a line of text (nothing to finish)\", \"\");\n\t\twriteText(text);\n\t} while (text != \"\");\n}",

		// Java
		"import java.io.*;\n\npublic class Object {\n\t\n\n}\n\n// Really just part of java.io package, but here to illustrate Examitext\npublic class StreamReader extends Object {\n\t// ...\n\n\tpublic String toString() { /* stuff */ }\n\tpublic booelan equals(Object obj) { /* stuff */ }\n}\npublic class BufferedReader extends StreamReader {\n\tpublic abstract String readLine();\n}\n\npublic class InputStreamReader extends StreamReader {\n\t\n\tpublic InputStreamReader(InputStream s) {\n\t\tthis.s = s;\n\t}\n\n\tprivate InputStream s;\n}\n\npublic class UserInputProcessor extends Object {\n\t\n\tpublic static void main(String[] args) {\n\t\tString s = \"\";\n\t\ttry {\n\t\t\tBufferedReader brInput = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tdo {\n\t\t\t\tSystem.out.println(\"Enter a line of text (nothing to finish): \")\n\t\t\t\ts = brInput.readLine();\n\t\t\t\tSystem.out.println(s);\n\t\t\t} while (!s.equals(\"\"));\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n}",

		// C#
		"using System.IO;\n\npublic class Object {\n\n}\n\npublic class UserInputProcessor extends Object {\n\t\n\tstatic void main(string[] args) {\n\t\tstring s = \"\";\n\t\ttry {\n\t\t\tdo {\n\t\t\t\tSystem.console.WriteLine(\"Enter a line of text (nothing to finish):\")\n\t\t\t\ts = System.console.ReadLine();\n\t\t\t\tSystem.console.WriteLine(s);\n\t\t\t} while (!s.equals(\"\"));\n\t\t} catch (IOException e) {\n\t\t\tSystem.Console.Error.WriteLine(e.ToString());\n\t\t}\n\t}\n}",

		// C++
		"/* Taken from Parcel Game Engine (http://code.google.com/p/parcel-game-engine/) source. */\n\n /*\n * File:   GameInterfaces.h\n * Author: Donald  Whyte\n *\n * Created on May 12, 2009, 6:46 PM\n */\n\n#ifndef INTERFACES_H\n#define INTERFACES_H\n\n/* These interfaces are used by parcel::game::Game.\n * Ideally, IWindow is independant from the other two interfaces\n * and ILogic only has to know about IGraphics to give it instructions\n * on what to draw. IGraphics shouldn't need to know about ILogic.\n * This all depends on the user's implementation, however and is not\n * the responsiblity of the framework to enforce such designs. */\n\nnamespace parcel\n{\n\n    /* Interface used by the game's window. Any window that will be\n     * used by Game needs to implement this.\n     *\n     * Update() is called at the beginning of every iteration of the\n     * main game loop. If it returns false, the game loop ends and\n     * Game calls the Close() method.\n     *\n     * Close() simply closes the window. */\n    class IWindow\n    {\n    public:\n        virtual bool Update() = 0;\n        virtual void Close() = 0;\n    };\n\n    /* Interface that is used to link the game's logic to the Game\n     * class. Update() is called many times per frame. If it returns,\n     * false, it tells Game to end and close the window. */\n    class ILogic\n    {\n    public:\n        virtual bool Update() = 0;\n    };\n\n    /* Interface used to draw the game's graphics\n     *\n     * Update() is called once per loop, drawing every specified by\n     * subclasses. */\n    class IGraphics\n    {\n    public:\n        virtual void Update() = 0;\n    };\n}\n\n#endif\n\n/*\n * File:   Test.h\n * Author: Donald Whyte\n *\n * Created on March 21, 2009, 10:03 AM\n */\n\n// DO NOT INCLUDE IN ENGINE RELEASES!!!\n\n#ifndef TEST_H\n#define TEST_H\n\n#include <iomanip>\n#include <GLee.h>\n#include \"Matrix.h\"\n#include \"Vector.h\"\n#include \"Logger.h\"\n#include \"Exceptions.h\"\n#include \"Colour.h\"\n#include \"Material.h\"\n#include \"Skin.h\"\n#include \"SkinManager.h\"\n#include \"Image.h\"\n#include \"OpenGLDevice.h\"\n#include \"RenderDevice.h\"\n#include \"Sound.h\"\n#include \"GLWindow.h\"\n#include \"Font.h\"\n#include \"Util.h\"\n#include \"DeviceParameters.h\"\n#include \"Quaternion.h\"\n#include \"ARenderer.h\"\n#include \"VBORenderer.h\"\n#include \"FixedFunctionLighting.h\"\n#include \"Primitives.h\"\n#include \"DMFModelLoader.h\"\n#include \"GameInterfaces.h\"\n#include \"Camera.h\"\n#include \"SpriteRenderer.h\"\n#include \"LuaManager.h\"\n#include \"Animator.h\"\n#include <windows.h>\n#include <iostream>\n#include <gl/gl.h>\n\nusing namespace std;\nusing namespace parcel;\nusing namespace parcel::debug;\nusing namespace parcel::maths;\nusing namespace parcel::general;\nusing namespace parcel::graphics;\nusing namespace parcel::sound;\nusing namespace parcel::game;\nusing namespace parcel::lua;\nusing namespace parcel::windows;\n\nclass Test : public IRenderable, public IGeometry, public ISkinned\n{\npublic:\n    vector<Vertex> v;\n    std::string skin;\n\n    Test(const std::string& skinID) : skin(skinID)\n    {\n        v.push_back(\n            Vertex(vector3f(200.0f, 200.0f, 5.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(300.0f, 200.0f, 5.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(200.0f, 300.0f, 5.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, 0.0f, 0.0f)));\n    }\n    virtual ~Test() {}\n\n    const vector<Vertex>& GetVertices() { return v; }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize() { return sizeof(Vertex) * 3; }\n\n    std::string& GetSkinID() { return skin; }\n\n    int GetPrimitiveType() { return PRIMITIVETYPE_TRIANGLE; }\n\n};\n\nclass Test2 : public IRenderable, public IGeometry, public IMatrix\n{\npublic:\n    vector<Vertex> v;\n    matrixf matrix;\n\n    Test2()\n    {\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, 1.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, 0.0f, 1.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, 1.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 0.0f, 1.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, 1.0f), vector2f(1.0f, 1.0f), vector3f(0.0f, 0.0f, 1.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, 1.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, 0.0f, 1.0f)));\n\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, -1.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 0.0f, -1.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, -1.0f), vector2f(1.0f, 1.0f), vector3f(0.0f, 0.0f, -1.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, -1.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, 0.0f, -1.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, -1.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 0.0f, -1.0f)));\n\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, -1.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, 1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, 1.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, 1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, 1.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, -1.0f), vector2f(1.0f, 1.0f), vector3f(0.0f, 1.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, -1.0f), vector2f(1.0f, 1.0f), vector3f(0.0f, -1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, -1.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, -1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, 1.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, -1.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, 1.0f), vector2f(1.0f, 1.0f), vector3f(0.0f, -1.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, -1.0f), vector2f(1.0f, 0.0f), vector3f(1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, -1.0f), vector2f(1.0f, 1.0f), vector3f(1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, 1.0f, 1.0f), vector2f(0.0f, 1.0f), vector3f(1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(1.0f, -1.0f, 1.0f), vector2f(0.0f, 0.0f), vector3f(1.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, -1.0f), vector2f(0.0f, 0.0f), vector3f(-1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, -1.0f, 1.0f), vector2f(1.0f, 0.0f), vector3f(-1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, 1.0f), vector2f(1.0f, 1.0f), vector3f(-1.0f, 0.0f, 0.0f)));\n        v.push_back(\n            Vertex(vector3f(-1.0f, 1.0f, -1.0f), vector2f(0.0f, 1.0f), vector3f(-1.0f, 0.0f, 0.0f)));\n\n        float data[16] =\n        {\n            200, 0, 0, 0,\n            0, 200, 0, 0,\n            0, 0, 200, 0,\n            -400, 0, 0, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~Test2() {}\n\n    virtual const vector<Vertex>& GetVertices()\n    {\n        return v;\n    }\n\n    virtual bool IsStatic() { return true; }\n\n    virtual int GetMemorySize() { return sizeof(Vertex) * 24; }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n    int GetPrimitiveType() { return PRIMITIVETYPE_QUAD; }\n\n};\n\nclass Test3 : public IRenderable, public IGeometry, public ISkinned, public IMatrix\n{\npublic:\n    vector<Vertex> v;\n    matrixf matrix;\n    std::string skin;\n\n    Test3(const std::string& skinID) : skin(skinID)\n    {\n        v.push_back(\n            Vertex(vector3f(0.0f, 0.0f, 50.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(100.0f, 0.0f, 50.0f), vector2f(0.5f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(0.0f, 100.0f, 50.0f), vector2f(0.0f, 0.5f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(100.0f, 100.0f, 50.0f), vector2f(0.0f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(150.0f, 100.0f, 50.0f), vector2f(1.0f, 0.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        v.push_back(\n            Vertex(vector3f(100.0f, 150.0f, 50.0f), vector2f(0.0f, 1.0f), vector3f(0.0f, 0.0f, 0.0f)));\n\n        float data[16] =\n        {\n            2, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            400, 0, 0, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~Test3() {}\n\n    const vector<Vertex>& GetVertices() { return v; }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize() { return sizeof(Vertex) * 6; }\n\n    const std::string& GetSkinID() { return skin; }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n    int GetPrimitiveType() { return PRIMITIVETYPE_TRIANGLE; }\n\n};\n\nclass TestGroup : public IRenderable, public IGroupRenderable, public IMatrix\n{\npublic:\n    vector<IRenderable*> renderables;\n    matrixf matrix;\n\n    TestGroup()\n    {\n        float data[16] =\n        {\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 250, 0, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~TestGroup()\n    {\n                for (unsigned int i = 0; (i < renderables.size()); i++)\n                {\n                    delete renderables[i];\n                    renderables[i] = NULL;\n                }\n    }\n\n        void AddRenderable(IRenderable* renderable)\n        {\n            renderables.push_back(renderable);\n        }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize()\n    {\n        int size = 0;\n\n                for (unsigned int i = 0; (i < renderables.size()); i++)\n                {\n                    size += renderables[i]->GetMemorySize();\n                }\n\n        return size;\n    }\n\n    unsigned int GetAmountOfRenderables()\n    {\n        return renderables.size();\n    }\n\n    IRenderable* GetRenderable(unsigned int i)\n    {\n        return renderables[i];\n    }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n};\nclass TestGroup2 : public IRenderable, public IGroupRenderable, public IMatrix\n{\npublic:\n    vector<IRenderable*> renderables;\n    matrixf matrix;\n\n    TestGroup2()\n    {\n        float data[16] =\n        {\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, -250, 0, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~TestGroup2()\n    {\n                for (unsigned int i = 0; (i < renderables.size()); i++)\n                {\n                    delete renderables[i];\n                    renderables[i] = NULL;\n                }\n    }\n\n        void AddRenderable(IRenderable* renderable)\n        {\n            renderables.push_back(renderable);\n        }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize()\n    {\n        int size = 0;\n\n                for (unsigned int i = 0; (i < renderables.size()); i++)\n                {\n                    size += renderables[i]->GetMemorySize();\n                }\n\n        return size;\n    }\n\n    unsigned int GetAmountOfRenderables()\n    {\n        return renderables.size();\n    }\n\n    IRenderable* GetRenderable(unsigned int i)\n    {\n        return renderables[i];\n    }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n};\n\nclass TestLight : public ALight\n{\npublic:\n    colourf colour;\n    vector3f position;\n\n    TestLight(const colourf& col, const vector3f& pos) : colour(col), position(pos)\n    {\n    }\n\n\n    virtual bool IsEnabled()\n    {\n        return true;\n    }\n\n    virtual LightType GetType()\n    {\n        return LIGHTTYPE_DIRECTION;\n    }\n\n    virtual colourf GetAmbientColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetDiffuseColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetSpecularColour()\n    {\n        return presetcolours::Green;\n    }\n\n    virtual vector3f GetDirection()\n    {\n        return position;\n    }\n};\nclass TestLight2 : public ALight\n{\npublic:\n    colourf colour;\n    vector3f position;\n\n    TestLight2(const colourf& col, const vector3f& pos) : colour(col), position(pos)\n    {\n    }\n\n\n    virtual bool IsEnabled()\n    {\n        return true;\n    }\n\n    virtual LightType GetType()\n    {\n        return LIGHTTYPE_POSITION;\n    }\n\n    virtual colourf GetAmbientColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetDiffuseColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetSpecularColour()\n    {\n        return presetcolours::Green;\n    }\n\n    virtual vector3f GetPosition()\n    {\n        return position;\n    }\n    virtual float GetConstantAttenuation()\n    {\n        return 1.0f;\n    }\n\n    virtual float GetLinearAttenuation()\n    {\n        return 0.0f;\n    }\n\n    virtual float GetQuadraticAttenuation()\n    {\n        return 0.0f;\n    }\n};\nclass TestLight3 : public ALight\n{\npublic:\n    colourf colour;\n    vector3f position, direction;\n\n    TestLight3(const colourf& col, const vector3f& pos, const vector3f& dir) : colour(col), position(pos), direction(dir)\n    {\n    }\n\n\n    virtual bool IsEnabled()\n    {\n        return true;\n    }\n\n    virtual LightType GetType()\n    {\n        return LIGHTTYPE_SPOTLIGHT;\n    }\n\n    virtual colourf GetAmbientColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetDiffuseColour()\n    {\n        return colour;\n    }\n\n    virtual colourf GetSpecularColour()\n    {\n        return presetcolours::Green;\n    }\n\n    virtual vector3f GetPosition()\n    {\n        return position;\n    }\n\n    virtual vector3f GetDirection()\n    {\n        return direction;\n    }\n\n    virtual float GetSpotlightCutoff()\n    {\n        return 90.0f;\n    }\n\n    virtual float GetSpotlightFocus()\n    {\n        return 10.0f;\n    }\n\n    virtual float GetConstantAttenuation()\n    {\n        return 1.0f;\n    }\n\n    virtual float GetLinearAttenuation()\n    {\n        return 0.0f;\n    }\n\n    virtual float GetQuadraticAttenuation()\n    {\n        return 0.0f;\n    }\n};\n\nclass TestModel : public IRenderable, public IGeometry, public ISkinned, public IMatrix\n{\npublic:\n    matrixf matrix;\n    DMFModelLoader model;\n\n    TestModel(const std::string& modelFilename, SkinManager* skinManager) : model(skinManager)\n    {\n        // Loads the model\n        model.LoadFromFile(modelFilename);\n\n        float data[16] =\n        {\n            600, 0, 0, 0,\n            0, 600, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~TestModel() {}\n\n    const vector<Vertex>& GetVertices() { return model.GetVertices(); }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize() { return sizeof(Vertex) * model.GetVertices().size(); }\n\n    const std::string& GetSkinID() { return model.GetSkins()[0]; }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n    int GetPrimitiveType() { return PRIMITIVETYPE_QUAD; }\n\n};\n\nclass TestModelIndex : public IRenderable, public IIndexedGeometry, public ISkinned, public IMatrix\n{\npublic:\n    matrixf matrix;\n    DMFModelLoader model;\n\n    TestModelIndex(const std::string& modelFilename, SkinManager* skinManager,\n        float x) : model(skinManager)\n    {\n        // Loads the model\n        model.LoadFromFile(modelFilename);\n\n        float data[16] =\n        {\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, x, 1\n        };\n\n        matrix = matrixf(4, 4, data);\n    }\n    virtual ~TestModelIndex() {}\n\n    const vector<Vertex>& GetVertices() { return model.GetVertices(); }\n\n    const vector<Triangle>& GetFaces() { return model.GetTriangles(); }\n\n    int GetTriangleMemorySize() { return (sizeof(Triangle) * model.GetTriangles().size()); }\n\n    bool IsStatic() { return true; }\n\n    int GetMemorySize() { return sizeof(Vertex) * model.GetVertices().size(); }\n\n    const std::string& GetSkinID() { return model.GetSkins()[0]; }\n\n    virtual void SetMatrix(const matrixf& m) { matrix = m; }\n\n    virtual const matrixf& GetMatrix() { return matrix; }\n\n    virtual void GetMatrixAsArray(float* a)\n    {\n        matrix.ToArray(a);\n    }\n\n    int GetPrimitiveType() { return PRIMITIVETYPE_QUAD; }\n\n};\n\n\nclass TestGraphics : public IGraphics\n{\n\n\npublic:\n\n    Logger log;\n    RenderDevice device;\n    IndexedVBORenderer vbo;\n    SpriteRenderer spriteRenderer;\n    cameraf camera;\n    FontRenderer font;\n\n    Animator animator;\n\n    TestGraphics(GLWindow* glw) :\n        log(), // Here to ensure that it gets constructed before the render device\n        device(&log),\n        vbo(&device, &log, true),\n        spriteRenderer(&device, &log, true),\n        font(\"heygorgeous.ttf\", 12)\n    {\n        // Loads model into renderer\n        TestModelIndex* mod = new TestModelIndex(\"Lasha.obj.dmf\", device.GetSkinManager(), -300.0f);\n        vbo.AddRenderable(mod);\n\n        // Generates projection matrices\n        maths::matrixf ortho;\n        ortho.ToOrthoProjection(0.0, glw->GetWidth(), 0.0, glw->GetHeight(), -1.0, 1.0);\n        camera.Perspective(65.0, (600.0 / 600.0), 1.0, 2000.0);\n        // Sets projection matrices\n        device.SetProjectionMatrix(RENDERMODE_2D, ortho);\n        device.SetProjectionMatrix(RENDERMODE_3D, camera.GetProjectionMatrix());\n        // Sets camera's properties\n        camera.SetBehavior(CAMERA_BEHAVIOR_FIRST_PERSON);\n        camera.SetPosition(vector3f(0.0f, 0.0f, 50.0f));\n        // Sets device's viewport size]\n        device.SetViewportSize(vector2i(glw->GetWidth(), glw->GetHeight()));\n    }\n\n    virtual ~TestGraphics() {}\n\n    void Update()\n    {\n        device.StartRendering();\n            // Draw 2D text and HUD\n            device.SetViewMatrix(maths::matrixf::Identity(4));\n            device.SetRenderMode(RENDERMODE_2D);\n            device.GetLighting()->DisableLighting();\n            spriteRenderer.Update();\n            spriteRenderer.Render();\n            font.SetHMargin(0.0f); font.SetVMargin(0.0f);\n            // Draws 3D scene, stuff like models\n            device.SetViewMatrix(camera.GetViewMatrix());\n            device.SetRenderMode(RENDERMODE_3D);\n            device.GetLighting()->EnableLighting();\n            vbo.Update();\n            vbo.Render();\n        device.EndRendering();\n    }\n\n};\n\nclass TestLogic : public ILogic\n{\n\nprivate:\n\n    TestGraphics* gfx;\n    LuaManager scripts;\n    int i;\n\npublic:\n\n    TestLogic(TestGraphics* graphics) : gfx(graphics), i(0)\n    {\n        // LUA SCRIPT TEST BELOW\n//        try\n//        {\n//            // Executes test script\n//            scripts.LoadAndExecuteScript(\"test.lua\");\n//            // Passes other values to the vm\n//            scripts.SetFloatToTable(\"names\", \"setted\", 82.0074f);\n//            // Retrives values from the vm and prints them\n//            cout << scripts.GetFloatFromTable(\"names\", \"setted\") << endl;\n//        }\n//        catch (debug::Exception& ex)\n//        {\n//            ex.PrintMessage();\n//        }\n    }\n\n    virtual ~TestLogic() {}\n\n    bool Update()\n    {\n        if (++i > 10000)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    }\n};\n\n#endif\n",
	]

];
